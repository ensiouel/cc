// Code generated by moq; DO NOT EDIT.
// github.com/matryer/moq

package storage

import (
	"cc/internal/model"
	"cc/internal/storage"
	"context"
	"github.com/google/uuid"
	"sync"
)

// Ensure, that ShortenStorageMock does implement ShortenStorage.
// If this is not the case, regenerate this file with moq.
var _ storage.ShortenStorage = &ShortenStorageMock{}

// ShortenStorageMock is a mock implementation of ShortenStorage.
//
//	func TestSomethingThatUsesShortenStorage(t *testing.T) {
//
//		// make and configure a mocked ShortenStorage
//		mockedShortenStorage := &ShortenStorageMock{
//			CreateFunc: func(ctx context.Context, shorten model.Shorten) error {
//				panic("mock out the Create method")
//			},
//			DeleteFunc: func(ctx context.Context, userID uuid.UUID, shortenID uint64) error {
//				panic("mock out the Delete method")
//			},
//			ExistsByIDFunc: func(ctx context.Context, userID uuid.UUID, id uint64) (bool, error) {
//				panic("mock out the ExistsByID method")
//			},
//			ExistsByURLFunc: func(ctx context.Context, userID uuid.UUID, url string) (bool, error) {
//				panic("mock out the ExistsByURL method")
//			},
//			GetByIDFunc: func(ctx context.Context, id uint64) (model.Shorten, error) {
//				panic("mock out the GetByID method")
//			},
//			GetByURLFunc: func(ctx context.Context, url string) (model.Shorten, error) {
//				panic("mock out the GetByURL method")
//			},
//			GetURLFunc: func(ctx context.Context, shortenID uint64) (string, error) {
//				panic("mock out the GetURL method")
//			},
//			SelectByTagsFunc: func(ctx context.Context, userID uuid.UUID, tags []string) (model.Shortens, error) {
//				panic("mock out the SelectByTags method")
//			},
//			SelectByUserFunc: func(ctx context.Context, userID uuid.UUID) (model.Shortens, error) {
//				panic("mock out the SelectByUser method")
//			},
//			UpdateFunc: func(ctx context.Context, shorten model.Shorten) error {
//				panic("mock out the Update method")
//			},
//		}
//
//		// use mockedShortenStorage in code that requires ShortenStorage
//		// and then make assertions.
//
//	}
type ShortenStorageMock struct {
	// CreateFunc mocks the Create method.
	CreateFunc func(ctx context.Context, shorten model.Shorten) error

	// DeleteFunc mocks the Delete method.
	DeleteFunc func(ctx context.Context, userID uuid.UUID, shortenID uint64) error

	// ExistsByIDFunc mocks the ExistsByID method.
	ExistsByIDFunc func(ctx context.Context, userID uuid.UUID, id uint64) (bool, error)

	// ExistsByURLFunc mocks the ExistsByURL method.
	ExistsByURLFunc func(ctx context.Context, userID uuid.UUID, url string) (bool, error)

	// GetByIDFunc mocks the GetByID method.
	GetByIDFunc func(ctx context.Context, id uint64) (model.Shorten, error)

	// GetByURLFunc mocks the GetByURL method.
	GetByURLFunc func(ctx context.Context, url string) (model.Shorten, error)

	// GetURLFunc mocks the GetURL method.
	GetURLFunc func(ctx context.Context, shortenID uint64) (string, error)

	// SelectByTagsFunc mocks the SelectByTags method.
	SelectByTagsFunc func(ctx context.Context, userID uuid.UUID, tags []string) (model.Shortens, error)

	// SelectByUserFunc mocks the SelectByUser method.
	SelectByUserFunc func(ctx context.Context, userID uuid.UUID) (model.Shortens, error)

	// UpdateFunc mocks the Update method.
	UpdateFunc func(ctx context.Context, shorten model.Shorten) error

	// calls tracks calls to the methods.
	calls struct {
		// Create holds details about calls to the Create method.
		Create []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Shorten is the shorten argument value.
			Shorten model.Shorten
		}
		// Delete holds details about calls to the Delete method.
		Delete []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// UserID is the userID argument value.
			UserID uuid.UUID
			// ShortenID is the shortenID argument value.
			ShortenID uint64
		}
		// ExistsByID holds details about calls to the ExistsByID method.
		ExistsByID []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// UserID is the userID argument value.
			UserID uuid.UUID
			// ID is the id argument value.
			ID uint64
		}
		// ExistsByURL holds details about calls to the ExistsByURL method.
		ExistsByURL []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// UserID is the userID argument value.
			UserID uuid.UUID
			// URL is the url argument value.
			URL string
		}
		// GetByID holds details about calls to the GetByID method.
		GetByID []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// ID is the id argument value.
			ID uint64
		}
		// GetByURL holds details about calls to the GetByURL method.
		GetByURL []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// URL is the url argument value.
			URL string
		}
		// GetURL holds details about calls to the GetURL method.
		GetURL []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// ShortenID is the shortenID argument value.
			ShortenID uint64
		}
		// SelectByTags holds details about calls to the SelectByTags method.
		SelectByTags []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// UserID is the userID argument value.
			UserID uuid.UUID
			// Tags is the tags argument value.
			Tags []string
		}
		// SelectByUser holds details about calls to the SelectByUser method.
		SelectByUser []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// UserID is the userID argument value.
			UserID uuid.UUID
		}
		// Update holds details about calls to the Update method.
		Update []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Shorten is the shorten argument value.
			Shorten model.Shorten
		}
	}
	lockCreate       sync.RWMutex
	lockDelete       sync.RWMutex
	lockExistsByID   sync.RWMutex
	lockExistsByURL  sync.RWMutex
	lockGetByID      sync.RWMutex
	lockGetByURL     sync.RWMutex
	lockGetURL       sync.RWMutex
	lockSelectByTags sync.RWMutex
	lockSelectByUser sync.RWMutex
	lockUpdate       sync.RWMutex
}

// Create calls CreateFunc.
func (mock *ShortenStorageMock) Create(ctx context.Context, shorten model.Shorten) error {
	if mock.CreateFunc == nil {
		panic("ShortenStorageMock.CreateFunc: method is nil but ShortenStorage.Create was just called")
	}
	callInfo := struct {
		Ctx     context.Context
		Shorten model.Shorten
	}{
		Ctx:     ctx,
		Shorten: shorten,
	}
	mock.lockCreate.Lock()
	mock.calls.Create = append(mock.calls.Create, callInfo)
	mock.lockCreate.Unlock()
	return mock.CreateFunc(ctx, shorten)
}

// CreateCalls gets all the calls that were made to Create.
// Check the length with:
//
//	len(mockedShortenStorage.CreateCalls())
func (mock *ShortenStorageMock) CreateCalls() []struct {
	Ctx     context.Context
	Shorten model.Shorten
} {
	var calls []struct {
		Ctx     context.Context
		Shorten model.Shorten
	}
	mock.lockCreate.RLock()
	calls = mock.calls.Create
	mock.lockCreate.RUnlock()
	return calls
}

// Delete calls DeleteFunc.
func (mock *ShortenStorageMock) Delete(ctx context.Context, userID uuid.UUID, shortenID uint64) error {
	if mock.DeleteFunc == nil {
		panic("ShortenStorageMock.DeleteFunc: method is nil but ShortenStorage.Delete was just called")
	}
	callInfo := struct {
		Ctx       context.Context
		UserID    uuid.UUID
		ShortenID uint64
	}{
		Ctx:       ctx,
		UserID:    userID,
		ShortenID: shortenID,
	}
	mock.lockDelete.Lock()
	mock.calls.Delete = append(mock.calls.Delete, callInfo)
	mock.lockDelete.Unlock()
	return mock.DeleteFunc(ctx, userID, shortenID)
}

// DeleteCalls gets all the calls that were made to Delete.
// Check the length with:
//
//	len(mockedShortenStorage.DeleteCalls())
func (mock *ShortenStorageMock) DeleteCalls() []struct {
	Ctx       context.Context
	UserID    uuid.UUID
	ShortenID uint64
} {
	var calls []struct {
		Ctx       context.Context
		UserID    uuid.UUID
		ShortenID uint64
	}
	mock.lockDelete.RLock()
	calls = mock.calls.Delete
	mock.lockDelete.RUnlock()
	return calls
}

// ExistsByID calls ExistsByIDFunc.
func (mock *ShortenStorageMock) ExistsByID(ctx context.Context, userID uuid.UUID, id uint64) (bool, error) {
	if mock.ExistsByIDFunc == nil {
		panic("ShortenStorageMock.ExistsByIDFunc: method is nil but ShortenStorage.ExistsByID was just called")
	}
	callInfo := struct {
		Ctx    context.Context
		UserID uuid.UUID
		ID     uint64
	}{
		Ctx:    ctx,
		UserID: userID,
		ID:     id,
	}
	mock.lockExistsByID.Lock()
	mock.calls.ExistsByID = append(mock.calls.ExistsByID, callInfo)
	mock.lockExistsByID.Unlock()
	return mock.ExistsByIDFunc(ctx, userID, id)
}

// ExistsByIDCalls gets all the calls that were made to ExistsByID.
// Check the length with:
//
//	len(mockedShortenStorage.ExistsByIDCalls())
func (mock *ShortenStorageMock) ExistsByIDCalls() []struct {
	Ctx    context.Context
	UserID uuid.UUID
	ID     uint64
} {
	var calls []struct {
		Ctx    context.Context
		UserID uuid.UUID
		ID     uint64
	}
	mock.lockExistsByID.RLock()
	calls = mock.calls.ExistsByID
	mock.lockExistsByID.RUnlock()
	return calls
}

// ExistsByURL calls ExistsByURLFunc.
func (mock *ShortenStorageMock) ExistsByURL(ctx context.Context, userID uuid.UUID, url string) (bool, error) {
	if mock.ExistsByURLFunc == nil {
		panic("ShortenStorageMock.ExistsByURLFunc: method is nil but ShortenStorage.ExistsByURL was just called")
	}
	callInfo := struct {
		Ctx    context.Context
		UserID uuid.UUID
		URL    string
	}{
		Ctx:    ctx,
		UserID: userID,
		URL:    url,
	}
	mock.lockExistsByURL.Lock()
	mock.calls.ExistsByURL = append(mock.calls.ExistsByURL, callInfo)
	mock.lockExistsByURL.Unlock()
	return mock.ExistsByURLFunc(ctx, userID, url)
}

// ExistsByURLCalls gets all the calls that were made to ExistsByURL.
// Check the length with:
//
//	len(mockedShortenStorage.ExistsByURLCalls())
func (mock *ShortenStorageMock) ExistsByURLCalls() []struct {
	Ctx    context.Context
	UserID uuid.UUID
	URL    string
} {
	var calls []struct {
		Ctx    context.Context
		UserID uuid.UUID
		URL    string
	}
	mock.lockExistsByURL.RLock()
	calls = mock.calls.ExistsByURL
	mock.lockExistsByURL.RUnlock()
	return calls
}

// GetByID calls GetByIDFunc.
func (mock *ShortenStorageMock) GetByID(ctx context.Context, id uint64) (model.Shorten, error) {
	if mock.GetByIDFunc == nil {
		panic("ShortenStorageMock.GetByIDFunc: method is nil but ShortenStorage.GetByID was just called")
	}
	callInfo := struct {
		Ctx context.Context
		ID  uint64
	}{
		Ctx: ctx,
		ID:  id,
	}
	mock.lockGetByID.Lock()
	mock.calls.GetByID = append(mock.calls.GetByID, callInfo)
	mock.lockGetByID.Unlock()
	return mock.GetByIDFunc(ctx, id)
}

// GetByIDCalls gets all the calls that were made to GetByID.
// Check the length with:
//
//	len(mockedShortenStorage.GetByIDCalls())
func (mock *ShortenStorageMock) GetByIDCalls() []struct {
	Ctx context.Context
	ID  uint64
} {
	var calls []struct {
		Ctx context.Context
		ID  uint64
	}
	mock.lockGetByID.RLock()
	calls = mock.calls.GetByID
	mock.lockGetByID.RUnlock()
	return calls
}

// GetByURL calls GetByURLFunc.
func (mock *ShortenStorageMock) GetByURL(ctx context.Context, url string) (model.Shorten, error) {
	if mock.GetByURLFunc == nil {
		panic("ShortenStorageMock.GetByURLFunc: method is nil but ShortenStorage.GetByURL was just called")
	}
	callInfo := struct {
		Ctx context.Context
		URL string
	}{
		Ctx: ctx,
		URL: url,
	}
	mock.lockGetByURL.Lock()
	mock.calls.GetByURL = append(mock.calls.GetByURL, callInfo)
	mock.lockGetByURL.Unlock()
	return mock.GetByURLFunc(ctx, url)
}

// GetByURLCalls gets all the calls that were made to GetByURL.
// Check the length with:
//
//	len(mockedShortenStorage.GetByURLCalls())
func (mock *ShortenStorageMock) GetByURLCalls() []struct {
	Ctx context.Context
	URL string
} {
	var calls []struct {
		Ctx context.Context
		URL string
	}
	mock.lockGetByURL.RLock()
	calls = mock.calls.GetByURL
	mock.lockGetByURL.RUnlock()
	return calls
}

// GetURL calls GetURLFunc.
func (mock *ShortenStorageMock) GetURL(ctx context.Context, shortenID uint64) (string, error) {
	if mock.GetURLFunc == nil {
		panic("ShortenStorageMock.GetURLFunc: method is nil but ShortenStorage.GetURL was just called")
	}
	callInfo := struct {
		Ctx       context.Context
		ShortenID uint64
	}{
		Ctx:       ctx,
		ShortenID: shortenID,
	}
	mock.lockGetURL.Lock()
	mock.calls.GetURL = append(mock.calls.GetURL, callInfo)
	mock.lockGetURL.Unlock()
	return mock.GetURLFunc(ctx, shortenID)
}

// GetURLCalls gets all the calls that were made to GetURL.
// Check the length with:
//
//	len(mockedShortenStorage.GetURLCalls())
func (mock *ShortenStorageMock) GetURLCalls() []struct {
	Ctx       context.Context
	ShortenID uint64
} {
	var calls []struct {
		Ctx       context.Context
		ShortenID uint64
	}
	mock.lockGetURL.RLock()
	calls = mock.calls.GetURL
	mock.lockGetURL.RUnlock()
	return calls
}

// SelectByTags calls SelectByTagsFunc.
func (mock *ShortenStorageMock) SelectByTags(ctx context.Context, userID uuid.UUID, tags []string) (model.Shortens, error) {
	if mock.SelectByTagsFunc == nil {
		panic("ShortenStorageMock.SelectByTagsFunc: method is nil but ShortenStorage.SelectByTags was just called")
	}
	callInfo := struct {
		Ctx    context.Context
		UserID uuid.UUID
		Tags   []string
	}{
		Ctx:    ctx,
		UserID: userID,
		Tags:   tags,
	}
	mock.lockSelectByTags.Lock()
	mock.calls.SelectByTags = append(mock.calls.SelectByTags, callInfo)
	mock.lockSelectByTags.Unlock()
	return mock.SelectByTagsFunc(ctx, userID, tags)
}

// SelectByTagsCalls gets all the calls that were made to SelectByTags.
// Check the length with:
//
//	len(mockedShortenStorage.SelectByTagsCalls())
func (mock *ShortenStorageMock) SelectByTagsCalls() []struct {
	Ctx    context.Context
	UserID uuid.UUID
	Tags   []string
} {
	var calls []struct {
		Ctx    context.Context
		UserID uuid.UUID
		Tags   []string
	}
	mock.lockSelectByTags.RLock()
	calls = mock.calls.SelectByTags
	mock.lockSelectByTags.RUnlock()
	return calls
}

// SelectByUser calls SelectByUserFunc.
func (mock *ShortenStorageMock) SelectByUser(ctx context.Context, userID uuid.UUID) (model.Shortens, error) {
	if mock.SelectByUserFunc == nil {
		panic("ShortenStorageMock.SelectByUserFunc: method is nil but ShortenStorage.SelectByUser was just called")
	}
	callInfo := struct {
		Ctx    context.Context
		UserID uuid.UUID
	}{
		Ctx:    ctx,
		UserID: userID,
	}
	mock.lockSelectByUser.Lock()
	mock.calls.SelectByUser = append(mock.calls.SelectByUser, callInfo)
	mock.lockSelectByUser.Unlock()
	return mock.SelectByUserFunc(ctx, userID)
}

// SelectByUserCalls gets all the calls that were made to SelectByUser.
// Check the length with:
//
//	len(mockedShortenStorage.SelectByUserCalls())
func (mock *ShortenStorageMock) SelectByUserCalls() []struct {
	Ctx    context.Context
	UserID uuid.UUID
} {
	var calls []struct {
		Ctx    context.Context
		UserID uuid.UUID
	}
	mock.lockSelectByUser.RLock()
	calls = mock.calls.SelectByUser
	mock.lockSelectByUser.RUnlock()
	return calls
}

// Update calls UpdateFunc.
func (mock *ShortenStorageMock) Update(ctx context.Context, shorten model.Shorten) error {
	if mock.UpdateFunc == nil {
		panic("ShortenStorageMock.UpdateFunc: method is nil but ShortenStorage.Update was just called")
	}
	callInfo := struct {
		Ctx     context.Context
		Shorten model.Shorten
	}{
		Ctx:     ctx,
		Shorten: shorten,
	}
	mock.lockUpdate.Lock()
	mock.calls.Update = append(mock.calls.Update, callInfo)
	mock.lockUpdate.Unlock()
	return mock.UpdateFunc(ctx, shorten)
}

// UpdateCalls gets all the calls that were made to Update.
// Check the length with:
//
//	len(mockedShortenStorage.UpdateCalls())
func (mock *ShortenStorageMock) UpdateCalls() []struct {
	Ctx     context.Context
	Shorten model.Shorten
} {
	var calls []struct {
		Ctx     context.Context
		Shorten model.Shorten
	}
	mock.lockUpdate.RLock()
	calls = mock.calls.Update
	mock.lockUpdate.RUnlock()
	return calls
}
